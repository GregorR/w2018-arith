#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

#include "arith-treefix.h"

/* Fix an arithmetic tree generated by the LL parser */
struct Tree *fix(struct Tree *tree)
{
    struct Tree *left, *right, *repl;
    int i, done;

    /* Terminals never need to be fixed */
    if (tree->symbol.terminal)
        return tree;

    /* Nonterminals need to be rotated, perhaps several times */
    done = 0;
    while (!done) {
        switch (tree->symbol.value) {
            case NT_S:
                /* Need to lift if it ends with an S' */
                if (tree->children[tree->childrenCt-1]->symbol.value == NT_SP) {
                    right = tree->children[tree->childrenCt-1];

                    /* Regardless we remove it from this tree */
                    tree->childrenCt--;

                    /* Look at the suffix */
                    if (right->childrenCt == 0) {
                        /* Nothing to add */
                        done = 1;

                    } else {
                        /* Lift */
                        repl = newTree(tree->symbol, NULL, 3);
                        repl->children[0] = tree->children[0];
                        repl->children[1] = right->children[0];
                        repl->children[2] = right->children[1];
                        tree = repl;

                    }

                    /*free(right);*/

                } else {
                    /* No suffix */
                    done = 1;

                }
                break;

            case NT_A:
            case NT_M:
                /* Need to rotate if it ends with an A' or M' */
                if (tree->children[tree->childrenCt-1]->symbol.value == tree->symbol.value + 1) {
                    right = tree->children[tree->childrenCt-1];

                    /* Regardless we remove it from this tree */
                    tree->childrenCt--;

                    /* The right hand side is the suffix */
                    if (right->childrenCt == 0) {
                        /* Epsilon suffix, just discard it */
                        done = 1;

                    } else {
                        /* Rotate */
                        repl = newTree(tree->symbol, NULL, right->childrenCt + 1);
                        repl->children[0] = tree;
                        for (i = 0; i < right->childrenCt; i++)
                            repl->children[i+1] = right->children[i];
                        tree = repl;

                    }

                    free(right);

                } else {
                    /* No suffix */
                    done = 1;

                }
                break;

            default:
                done = 1;
        }
    }

    /* Fix the children */
    for (i = 0; i < tree->childrenCt; i++)
        tree->children[i] = fix(tree->children[i]);

    /* For assignment, lift the left side out */
    if (tree->symbol.value == NT_S && tree->childrenCt > 1) {
        left = tree->children[0];
        while (left->childrenCt == 1) {
            tree->children[0] = left->children[0];
            free(left);
            left = tree->children[0];
        }
    }

    return tree;
}
